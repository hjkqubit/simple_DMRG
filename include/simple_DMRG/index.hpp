/**
 * @file index.hpp
 * @brief Defines the `Index` class that keeps track of physical and link indices.
 *
 *
 * Author: Hyeongjin Kim
 * Date: 2024
 * Version: 1.0
 */

#ifndef INDEX_HPP
#define INDEX_HPP

#include <iostream>
#include <tuple>
#include <unordered_map>
#include <utility> // for std::pair
#include <uuid/uuid.h>
#include <vector>

/**
 * @brief A simple `Index` class that keeps track of physical and link indices.
 *
 * This class create indices that can be used to keep track of the tensor dimensions. This also
 * includes methods that can modify the indices, such as raising or lowering their `plevel`'s.
 */
class Index {
public:
    /**
     * @brief Default constructor for `Index`.
     *
     * Initializes an empty `Index` class object. Each construction of `Index` randomly generates a
     * unique identifier (UUID).
     */
    Index();

    /**
     * @brief Constructor for `Index`.
     *
     * Each construction of `Index` randomly generates a unique identifier (UUID).
     *
     * @param dims The dimension of the index.
     * @param index_tag The type of the dimension: physical or link.
     * @param plevel The prime level of the index: default is 0.
     */
    Index(int dims, std::string index_tag = "link", int plevel = 0);

    /**
     * @brief Default deconstructor for `Index`.
     */
    ~Index();

    /**
     * @brief Copy constructor for `Index`.
     *
     * Creates a copy of the other `Index` object.
     *
     * @param other The other `Index` object to copy from.
     */
    Index(const Index &other);

    /**
     * @brief Assignment operator for `Index`.
     *
     * Assigns the values from another `Index` object to this current one.
     *
     * @param other The other `Index` object to copy from.
     */
    Index &operator=(const Index &other);

    /**
     * @brief Gets the dimension of the index.
     *
     * @return The dimension of the index as an `int`.
     */
    int get_dims() const;

    /**
     * @brief Gets the tag (physical or link) of the index.
     *
     * @return The tag of the index as an `std::string`.
     */
    std::string get_index_tag() const;

    /**
     * @brief Gets the current prime level of the index.
     *
     * @return The prime level of the index as an `int`.
     */
    int get_plevel() const;

    /**
     * @brief Sets a new dimension of the index.
     *
     * @param new_dims The new dimension to be set.
     * @return A reference to this `Index` object.
     */
    Index &set_dims(int new_dims);

    /**
     * @brief Sets the prime level of the index.
     *
     * @param new_plevel The new prime level to be set.
     * @return A reference to this `Index` object.
     */
    Index &set_prime(int new_plevel);

    /**
     * @brief Resets the prime level of the index to be zero.
     *
     * @return A reference to this `Index` object with `plevel = 0`.
     */
    Index &reset_prime();

    /**
     * @brief Increases the prime level of the index by one.
     *
     * @return A reference to this `Index` object with `plevel ++`.
     */
    Index &prime();

    /**
     * @brief Decreases the prime level of the index by one.
     *
     * @return A reference to this `Index` object with `plevel --`.
     */
    Index &unprime();

    /**
     * @brief Compares two `Index` objects for equality.
     *
     * Two indices are equal if both their internal `id` and `plevel` values are equal.
     *
     * @param rhs The other `Index` object to compare against.
     * @return True if indices are equal and False otherwise.
     */
    bool operator==(const Index &rhs) const;

    /**
     * @brief Generates a hash value for the `Index` object.
     *
     * The hash value is generated by combining the hashes of `plevel` and `id`.
     *
     * @return The hash value for this `Index` object.
     */
    std::size_t hash() const;

    /**
     * @brief Outputs the `Index` object as a string.
     *
     * @param os The output stream.
     * @param index The `Index` object to output.
     * @return The output stream.
     */
    friend std::ostream &operator<<(std::ostream &os, const Index &index);

private:
    /**
     * @brief The dimension of the index.
     */
    int dims;

    /**
     * @brief The tag of the index.
     */
    std::string index_tag;

    /**
     * @brief The prime level of the index.
     */
    int plevel;

    /**
     * @brief Unique identifier for the index.
     */
    uuid_t id;

    /**
     * @brief Generates a string representation of the unique identifier.
     *
     * @return The string representation of `id`.
     */
    std::string get_id_string() const;
};

// Specialize std::hash for Index
namespace std {
    /**
     * @brief Hash specialization for the `Index` class.
     *
     * This struct provides a specialization for std::hash to enable hasing of `Index` objects.
     */
    template <> struct hash<Index> {
        /**
         * @brief Generates the hash value for the `Index` object.
         *
         * @param idx The `Index` object to get hashed.
         * @return The computed hash value.
         */
        std::size_t operator()(const Index &idx) const noexcept {
            return idx.hash(); // call the hash method from `Index` class
        }
    };
}

/**
 * @brief Finds and outputs the contraction modes between two vectors of `Index` objects.
 *
 * This function creates unique modes given two vectors of `Index` objects depending on whether an
 * `Index` object is in both `A` and `B`. Modes are used in performing tensor contractions: tensors
 * are contracted along the matching modes.
 *
 * @param A The first vector of `Index` objects.
 * @param B The second vector of `Index` objects.
 * @return A vector of the format `{A_list, B_list, C_list, C_pos}`. `A_list` and `B_list` refer to
 * the unique modes for `A` and `B`, respectively. If a match between `A_list` and `B_list` is
 * found, then that entry in `B_list` will take the corresponding value from `A_list`. `C_list`
 * corresponds to the unmatched modes. `C_pos` returns the positions of modes in `C_list` in the
 * combined vector `{A, B}`.
 *
 * Example:
 *
 * @code
 * Index a(3);
 * Index b(4);
 * Index c(2);
 * Index d(6);
 *
 * std::vector<Index> left = {a,d,b};
 * std::vector<Index> right = {b,d,c};
 *
 * std::vector<std::vector<int>> res = find_contract_modes(left, right); // res = {{0,1,2}, {2,1,3},
 * {0,3}, {0,6}}
 * @endcode
 */
std::vector<std::vector<int>> find_contract_modes(const std::vector<Index> &A,
                                                  const std::vector<Index> &B);

#endif // INDEX_HPP
